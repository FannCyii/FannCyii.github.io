<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>weak实现原理 | 时光荏苒</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="程序员" />
  

  <meta name="description" content="概要初始化weak变量的时候会调用storeWeak，后会先在全局列表SideTables中找到该变量指针指向的对象的weak_table_t 再通过weak_table_t获取对应该对象的若引用表实体weak_entry_t（每个weak_entry_t都包含对象地址和对应该对象的弱引用表），之后会释放删除旧对象的弱引用表中的变量指针，并在新对象的弱引用表中注册该变量指针。而对象释放的时候也会调">
<meta property="og:type" content="article">
<meta property="og:title" content="weak实现原理">
<meta property="og:url" content="https://fanncyii.github.io/2017/08/23/weak实现原理/index.html">
<meta property="og:site_name" content="时光荏苒">
<meta property="og:description" content="概要初始化weak变量的时候会调用storeWeak，后会先在全局列表SideTables中找到该变量指针指向的对象的weak_table_t 再通过weak_table_t获取对应该对象的若引用表实体weak_entry_t（每个weak_entry_t都包含对象地址和对应该对象的弱引用表），之后会释放删除旧对象的弱引用表中的变量指针，并在新对象的弱引用表中注册该变量指针。而对象释放的时候也会调">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-23T06:08:21.613Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="weak实现原理">
<meta name="twitter:description" content="概要初始化weak变量的时候会调用storeWeak，后会先在全局列表SideTables中找到该变量指针指向的对象的weak_table_t 再通过weak_table_t获取对应该对象的若引用表实体weak_entry_t（每个weak_entry_t都包含对象地址和对应该对象的弱引用表），之后会释放删除旧对象的弱引用表中的变量指针，并在新对象的弱引用表中注册该变量指针。而对象释放的时候也会调">

  

  
    <link rel="icon" href="/longmao.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">To</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">To</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_blank"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概要"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-相关的几个结构体"><span class="toc-text">1 相关的几个结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SideTable结构体"><span class="toc-text">1.1 SideTable结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-StripedMap类"><span class="toc-text">1.2 StripedMap类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-weak-table-t结构体"><span class="toc-text">1.3 weak_table_t结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-weak-entry-t结构体"><span class="toc-text">1.4 weak_entry_t结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-weak弱引用处理流程"><span class="toc-text">2 weak弱引用处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-全局hash表的初始化"><span class="toc-text">2.1 全局hash表的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-全局SideTables表的使用"><span class="toc-text">2.2 全局SideTables表的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-弱引用的删除与注册"><span class="toc-text">2.3 弱引用的删除与注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-对象的释放"><span class="toc-text">2.4 对象的释放</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-weak实现原理" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">weak实现原理</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.08.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Kivan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/category/iOS/">iOS</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="https://fanncyii.github.io//2017/08/23/weak实现原理/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>初始化<code>weak</code>变量的时候会调用<code>storeWeak</code>，后会先在全局列表<code>SideTables</code>中找到该变量指针指向的对象的<code>weak_table_t</code> 再通过<code>weak_table_t</code>获取对应该对象的若引用表实体<code>weak_entry_t</code>（每个<code>weak_entry_t</code>都包含对象地址和对应该对象的弱引用表），之后会释放删除旧对象的弱引用表中的变量指针，并在新对象的弱引用表中注册该变量指针。而对象释放的时候也会调用调用<code>storeWeak</code>，只是传入的新对象值是<code>nil</code>。</p>
<p>下面详细讲解</p>
<h2 id="1-相关的几个结构体"><a href="#1-相关的几个结构体" class="headerlink" title="1 相关的几个结构体"></a>1 相关的几个结构体</h2><h3 id="1-1-SideTable结构体"><a href="#1-1-SideTable结构体" class="headerlink" title="1.1 SideTable结构体"></a>1.1 <code>SideTable</code>结构体</h3><p>SideTable结构体包含一个自旋锁、引用计数表、weak表。结构体的构造函数分配了内存空间。其实在runtime加载到内存后就是初始化一个定长的SideTable数组（StripedMap），用于全局存储弱引用表相关的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(&quot;Do not delete SideTable.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void lock() &#123; slock.lock(); &#125;</span><br><span class="line">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    void forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    // Address-ordered lock discipline for a pair of side tables.</span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-StripedMap类"><a href="#1-2-StripedMap类" class="headerlink" title="1.2 StripedMap类"></a>1.2 <code>StripedMap</code>类</h3><p>查看StripedMap类的部分代码如下，该类在初始化的时候回定义一个定长为StripeCount的数组，数组的每一个item值类型为出入的模板值类型T。最终数据也是存储在这个array数组中。<br>重点看重载的<code>[]</code>运算符函数：<code>T&amp; operator[] (const void *p)</code>，使用对象内存地址为key获取map中的值的时候(类似<code>xxxx[obj]</code>的方式),就会调用<code>[]</code>运算符,运算符会通过indexForPointer方法对对象的内存地址进行各种位运算以及取模，最终获得一个索引值，用这个索引值来获取array中的值。  </p>
<blockquote>
<p>可以看出，<em>StripedMap其实这里就是一个哈希表，indexForPointer就是哈希函数,表的长度为StripeCount.<br>该hash表中，不同对象可以定位得到相同的SideTable,最终通过对象地址来遍历得到对应的entery</em>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   ...</span><br><span class="line">#if TARGET_OS_EMBEDDED</span><br><span class="line">    enum &#123; StripeCount = 8 &#125;;</span><br><span class="line">#else</span><br><span class="line">    enum &#123; StripeCount = 64 &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    struct PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[] (const void *p) const &#123; </span><br><span class="line">        return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p]; </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="1-3-weak-table-t结构体"><a href="#1-3-weak-table-t结构体" class="headerlink" title="1.3 weak_table_t结构体"></a>1.3 <code>weak_table_t</code>结构体</h3><p>全局<code>SideTables()</code>,中包含多个<code>SideTable</code>,每个<code>SideTable</code>包含一个<code>weak_table_t</code>。因为<code>SideTables()</code>是全局的，所以也可以说这里的<code>weak_table_t</code>也是全局的了，只是获取这个<code>weak_table_t</code>不是直接在全局表中得到的，而是要通过对象内存地址通过hash函数计算得到<code>SideTable</code>，从而再得到<code>weak_table_t</code>。</p>
<blockquote>
<p>看该结构很明显，<code>weak_entries</code>就是最终的各个对象的弱引用表组成的链表，每个<code>weak_entry_t</code>表示一个对象的弱引用表。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-weak-entry-t结构体"><a href="#1-4-weak-entry-t结构体" class="headerlink" title="1.4 weak_entry_t结构体"></a>1.4 <code>weak_entry_t</code>结构体</h3><p><code>weak_entry_t</code>就是每个对象的弱引用表的载体。如下代码，<code>referent</code>就是当前对象的内存地址，用于识别当前<code>entry</code>。而弱引用表则是通过一个共用体来实现的，这个共用体，是由一两个结构体共享的，一个结构体代表一个链表，一个结构体代表一个数组，数组长度为4(<code>WEAK_INLINE_COUNT</code>宏为4)。而这个链表和数组存储的值都是<code>weak_referrer_t</code>类型，<code>weak_referrer_t</code>就是弱引用变量指针的地址。最开始时存入弱引用指针到数组中，当数组存满时就会将数组改成链表，将所有的弱引用变量指针存储到链表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool out_of_line() &#123;</span><br><span class="line">        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(this, &amp;other, sizeof(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[0] = newReferrer;</span><br><span class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-weak弱引用处理流程"><a href="#2-weak弱引用处理流程" class="headerlink" title="2 weak弱引用处理流程"></a>2 weak弱引用处理流程</h2><p>接下来具体说下weak弱引用表的处理流程。</p>
<h3 id="2-1-全局hash表的初始化"><a href="#2-1-全局hash表的初始化" class="headerlink" title="2.1 全局hash表的初始化"></a>2.1 全局hash表的初始化</h3><p>在网络上搜索weak原理实现时，都说弱引用表存储在全局hash表中，但是并没有说明存在哪里，什么时候初始化的。其实看runtime源码可以很清楚的知晓，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alignas(StripedMap&lt;SideTable&gt;) static uint8_t </span><br><span class="line">    SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"></span><br><span class="line">static void SideTableInit() &#123;</span><br><span class="line">    new (SideTableBuf) StripedMap&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取全局表的方法就是这个全局函数SideTables()，而这个全局函数最终返回的其实就是SideTableBuf这个全局数组，而这个数组里面装的就是一个StripedMap<sidetable>类型的hash表（这里使用了C++非关联类型装换函数reinterpret_cast，感兴趣的童鞋可以自己研究下）。那么这个全局hash表是何时初始化的呢？看<code>static void SideTableInit()</code>函数一目了然，通过查找调用路径如：</sidetable></p>
<blockquote>
<p><code>map_images</code>-&gt;<code>map_images_nolock</code>-&gt;<code>arr_init</code>-&gt;<code>SideTableInit</code><br>所以，这个全局初始化表是在<code>map_images</code>调用后进行的，也就是<code>runtime</code>最初加载完的时候进行的，而且会执行一次【<a href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">map_images的调用时机</a>】</p>
</blockquote>
<h3 id="2-2-全局SideTables表的使用"><a href="#2-2-全局SideTables表的使用" class="headerlink" title="2.2 全局SideTables表的使用"></a>2.2 全局SideTables表的使用</h3><p>什么时候会存储弱引用数据呢？看如下源码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Initialize a fresh weak pointer to some object location. </span><br><span class="line"> * It would be used for code like: </span><br><span class="line"> *</span><br><span class="line"> * (The nil case) </span><br><span class="line"> * __weak id weakPtr;</span><br><span class="line"> * (The non-nil case) </span><br><span class="line"> * NSObject *o = ...;</span><br><span class="line"> * __weak id weakPtr = o;</span><br><span class="line"> * </span><br><span class="line"> * This function IS NOT thread-safe with respect to concurrent </span><br><span class="line"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span><br><span class="line"> *</span><br><span class="line"> * @param location Address of __weak ptr. </span><br><span class="line"> * @param newObj Object ptr. </span><br><span class="line"> */</span><br><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释也写的很清楚，当给<code>__weak</code>修饰符修饰的变量赋值的时候，就会调用<code>storeWeak</code>并传入当前变量的指针（也就是旧对象地址指针的指针），和新对象地址，所以关键函数就是<code>storeWeak</code>,其部分源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   SideTable *oldTable;</span><br><span class="line">   SideTable *newTable;</span><br><span class="line"></span><br><span class="line">   // Acquire locks for old and new values.</span><br><span class="line">   // Order by lock address to prevent lock ordering problems. </span><br><span class="line">   // Retry if the old value changes underneath us.</span><br><span class="line">retry:</span><br><span class="line">   if (haveOld) &#123;</span><br><span class="line">       oldObj = *location;</span><br><span class="line">       oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       oldTable = nil;</span><br><span class="line">   &#125;</span><br><span class="line">   if (haveNew) &#123;</span><br><span class="line">       newTable = &amp;SideTables()[newObj];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       newTable = nil;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可见进入<code>storeWeak</code>后就会去查找全局hash表并分别获取新旧对象的SideTable,方式就是以对象地址为key通过全局hash表(通过SideTables()函数获取)查找获得。</p>
<p>接着就删除旧对象弱引用表中的弱引用指针，并在新对象弱引用表中添加弱引用指针。storeWeak调用的两个函数就对应这两个功能</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);  </span><br><span class="line">   </span><br><span class="line">&gt;newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-3-弱引用的删除与注册"><a href="#2-3-弱引用的删除与注册" class="headerlink" title="2.3 弱引用的删除与注册"></a>2.3 弱引用的删除与注册</h3><p>删除旧对象弱引用表中的弱引用指针，并在新对象弱引用表中添加弱引用指针，就是如下两个函数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, </span><br><span class="line">                        id *referrer_id);</span><br><span class="line">                        </span><br><span class="line">id </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, id referent_id, </span><br><span class="line">                      id *referrer_id, bool crashIfDeallocating);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>weak_unregister_no_lock</code>函数 ，在弱引用表中注销弱引用变量</li>
</ul>
<p>查看源码调用<code>weak_entry_for_referent</code>获取弱引用表实体<code>entry</code>，其主要功能就是一个<code>while</code>循环，通过对比<code>weak_table_t</code>表中每个<code>entery</code>的<code>referent</code>地址是否和当前referent（对象地址）相等，如果相等该<code>entry</code>就是该对象的弱引用表实体了。获取到了当前弱引用表实体就可以直接操作当前弱引用表了：</p>
<blockquote>
<p><code>remove_referrer(entry, referrer)</code>移除当前弱引用表中的<code>referrer</code>引用。最后如果当前弱引用表为空则会调用<code>weak_entry_remove(weak_table, entry)</code>将该表实体从<code>weak_table</code>中移除。</p>
</blockquote>
<ul>
<li><code>weak_register_no_lock</code>函数，在弱引用表中注册弱引用变量</li>
</ul>
<p>查看源码，注册这个功能主要如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">weak_entry_t *entry;</span><br><span class="line">if ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">    append_referrer(entry, referrer);</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">    weak_entry_t new_entry(referent, referrer);</span><br><span class="line">    weak_grow_maybe(weak_table);</span><br><span class="line">    weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是会先调用<code>weak_entry_for_referent</code>获取当前对象的弱引用表，如果没有就走else流程，给该对象新建弱引用表，并在<code>weak_table</code>装满<code>3/4</code>的容量时扩容，最后将该弱引用表实体插入到<code>weak_table</code>中。</p>
<h3 id="2-4-对象的释放"><a href="#2-4-对象的释放" class="headerlink" title="2.4 对象的释放"></a>2.4 对象的释放</h3><p>这里大概就说完了weak的主要实现原理了。当对象释放的时候，会调用<code>objc_destroyWeak</code>方法来处理所以的弱引用变量指针，并清空若应用表，对比下<code>objc_destroyWeak</code>和<code>objc_initWeak</code>就很明显了，也调用了<code>storeWeak</code>只是传入的新对象是nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//objc_destroyWeak</span><br><span class="line">void</span><br><span class="line">objc_destroyWeak(id *location)</span><br><span class="line">&#123;</span><br><span class="line">    (void)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就酱，好记性不如烂笔头，加油</p>
</blockquote>

    
  </div>

  
      <div class="git"></div>
  

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/07/23/AutoReleasePool实现原理/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="hide pull-right" href="/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_blank"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'kivan';
    
    var disqus_url = 'https://fanncyii.github.io/2017/08/23/weak实现原理/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//kivan.disqus.com/count.js" async></script>



    
    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment" ></div>
    <script>
        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "",
            appKey: "",
            avatar:'mm',
            placeholder: "Just go go",
            guest_info:guest_info,
            pageSize:'10'
        });
    </script>
  
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
